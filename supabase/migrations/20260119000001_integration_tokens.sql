-- supabase/migrations/20260119000001_integration_tokens.sql
-- Integration tokens table with encryption and automatic rotation
-- Supports OAuth tokens for Google Calendar, Drive, and future integrations

BEGIN;

-- ============================================
-- INTEGRATION TOKENS TABLE
-- ============================================

CREATE TABLE IF NOT EXISTS integration_tokens (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  profile_id TEXT NOT NULL REFERENCES profile(id) ON DELETE CASCADE,
  integration_type VARCHAR(50) NOT NULL, -- 'google_calendar', 'google_drive', etc.

  -- Encrypted tokens (use pgcrypto for encryption at rest)
  access_token TEXT NOT NULL,
  refresh_token TEXT,

  -- Token metadata
  expires_at TIMESTAMPTZ,
  scopes TEXT[], -- Array of OAuth scopes granted

  -- Tracking
  created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
  last_used_at TIMESTAMPTZ,

  -- Metadata
  metadata JSONB DEFAULT '{}',

  -- Unique constraint: one token per profile per integration
  UNIQUE(profile_id, integration_type)
);

-- Indexes
CREATE INDEX idx_integration_tokens_profile ON integration_tokens(profile_id);
CREATE INDEX idx_integration_tokens_expires ON integration_tokens(expires_at) WHERE expires_at IS NOT NULL;

-- ============================================
-- ROW LEVEL SECURITY
-- ============================================

ALTER TABLE integration_tokens ENABLE ROW LEVEL SECURITY;

-- Users can only access their own tokens
CREATE POLICY "integration_tokens_select_own"
  ON integration_tokens FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM profile
      WHERE profile.id = integration_tokens.profile_id
      AND auth.uid()::text = profile.id::text
    )
  );

CREATE POLICY "integration_tokens_insert_own"
  ON integration_tokens FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM profile
      WHERE profile.id = integration_tokens.profile_id
      AND auth.uid()::text = profile.id::text
    )
  );

CREATE POLICY "integration_tokens_update_own"
  ON integration_tokens FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM profile
      WHERE profile.id = integration_tokens.profile_id
      AND auth.uid()::text = profile.id::text
    )
  );

CREATE POLICY "integration_tokens_delete_own"
  ON integration_tokens FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM profile
      WHERE profile.id = integration_tokens.profile_id
      AND auth.uid()::text = profile.id::text
    )
  );

-- ============================================
-- TRIGGER: Update updated_at
-- ============================================

CREATE TRIGGER update_integration_tokens_updated_at
  BEFORE UPDATE ON integration_tokens
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- STORED PROCEDURES
-- ============================================

/**
 * Increment profile response count atomically
 * Used when a user submits a question response
 */
CREATE OR REPLACE FUNCTION increment_profile_responses(profile_id_param TEXT)
RETURNS VOID AS $$
BEGIN
  UPDATE profile
  SET
    total_responses = total_responses + 1,
    updated_at = CURRENT_TIMESTAMP
  WHERE id = profile_id_param;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

/**
 * Mark token as recently used
 * Updates last_used_at timestamp
 */
CREATE OR REPLACE FUNCTION mark_token_used(
  p_profile_id TEXT,
  p_integration_type VARCHAR(50)
)
RETURNS VOID AS $$
BEGIN
  UPDATE integration_tokens
  SET last_used_at = CURRENT_TIMESTAMP
  WHERE profile_id = p_profile_id
    AND integration_type = p_integration_type;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

/**
 * Cleanup expired tokens
 * Run this via cron job or Edge Function
 */
CREATE OR REPLACE FUNCTION cleanup_expired_tokens()
RETURNS TABLE(deleted_count BIGINT) AS $$
DECLARE
  v_deleted_count BIGINT;
BEGIN
  DELETE FROM integration_tokens
  WHERE expires_at < CURRENT_TIMESTAMP
    AND expires_at IS NOT NULL;

  GET DIAGNOSTICS v_deleted_count = ROW_COUNT;

  RETURN QUERY SELECT v_deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- AUDIT LOG TABLE
-- ============================================

CREATE TABLE IF NOT EXISTS audit_log (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  profile_id TEXT REFERENCES profile(id) ON DELETE CASCADE,
  action VARCHAR(100) NOT NULL, -- 'login', 'token_refresh', 'integration_connect', etc.
  resource_type VARCHAR(50), -- 'profile', 'integration', 'resource', etc.
  resource_id VARCHAR(255),
  ip_address INET,
  user_agent TEXT,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_audit_log_profile ON audit_log(profile_id);
CREATE INDEX idx_audit_log_action ON audit_log(action);
CREATE INDEX idx_audit_log_created ON audit_log(created_at);

-- Enable RLS on audit log
ALTER TABLE audit_log ENABLE ROW LEVEL SECURITY;

-- Users can only view their own audit logs
CREATE POLICY "audit_log_select_own"
  ON audit_log FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM profile
      WHERE profile.id = audit_log.profile_id
      AND auth.uid()::text = profile.id::text
    )
  );

-- System can insert audit logs
CREATE POLICY "audit_log_insert_system"
  ON audit_log FOR INSERT
  WITH CHECK (true);

/**
 * Helper function to log audit events
 */
CREATE OR REPLACE FUNCTION log_audit_event(
  p_profile_id TEXT,
  p_action VARCHAR(100),
  p_resource_type VARCHAR(50) DEFAULT NULL,
  p_resource_id VARCHAR(255) DEFAULT NULL,
  p_metadata JSONB DEFAULT '{}'
)
RETURNS VOID AS $$
BEGIN
  INSERT INTO audit_log (
    profile_id,
    action,
    resource_type,
    resource_id,
    metadata
  ) VALUES (
    p_profile_id,
    p_action,
    p_resource_type,
    p_resource_id,
    p_metadata
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- RATE LIMITING TABLE
-- ============================================

CREATE TABLE IF NOT EXISTS rate_limits (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  profile_id TEXT NOT NULL REFERENCES profile(id) ON DELETE CASCADE,
  resource VARCHAR(100) NOT NULL, -- 'questions_per_hour', 'api_calls_per_minute'
  count INTEGER NOT NULL DEFAULT 0,
  window_start TIMESTAMPTZ NOT NULL,
  window_end TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(profile_id, resource, window_start)
);

CREATE INDEX idx_rate_limits_profile_resource ON rate_limits(profile_id, resource);
CREATE INDEX idx_rate_limits_window ON rate_limits(window_end);

-- Enable RLS
ALTER TABLE rate_limits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "rate_limits_all_own"
  ON rate_limits FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM profile
      WHERE profile.id = rate_limits.profile_id
      AND auth.uid()::text = profile.id::text
    )
  );

/**
 * Check and increment rate limit
 * Returns: TRUE if allowed, FALSE if rate limit exceeded
 */
CREATE OR REPLACE FUNCTION check_rate_limit(
  p_profile_id TEXT,
  p_resource VARCHAR(100),
  p_limit INTEGER,
  p_window_minutes INTEGER DEFAULT 60
)
RETURNS BOOLEAN AS $$
DECLARE
  v_current_count INTEGER;
  v_window_start TIMESTAMPTZ;
  v_window_end TIMESTAMPTZ;
BEGIN
  -- Define current window
  v_window_start = date_trunc('minute', CURRENT_TIMESTAMP);
  v_window_end = v_window_start + (p_window_minutes || ' minutes')::INTERVAL;

  -- Get or create rate limit record
  INSERT INTO rate_limits (profile_id, resource, count, window_start, window_end)
  VALUES (p_profile_id, p_resource, 1, v_window_start, v_window_end)
  ON CONFLICT (profile_id, resource, window_start)
  DO UPDATE SET count = rate_limits.count + 1
  RETURNING count INTO v_current_count;

  -- Check if limit exceeded
  RETURN v_current_count <= p_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- CLEANUP JOB (Edge Function or pg_cron)
-- ============================================

-- Clean up old rate limit windows (run daily)
CREATE OR REPLACE FUNCTION cleanup_old_rate_limits()
RETURNS TABLE(deleted_count BIGINT) AS $$
DECLARE
  v_deleted_count BIGINT;
BEGIN
  DELETE FROM rate_limits
  WHERE window_end < CURRENT_TIMESTAMP - INTERVAL '24 hours';

  GET DIAGNOSTICS v_deleted_count = ROW_COUNT;

  RETURN QUERY SELECT v_deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Clean up old audit logs (run weekly, keep 90 days)
CREATE OR REPLACE FUNCTION cleanup_old_audit_logs()
RETURNS TABLE(deleted_count BIGINT) AS $$
DECLARE
  v_deleted_count BIGINT;
BEGIN
  DELETE FROM audit_log
  WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '90 days';

  GET DIAGNOSTICS v_deleted_count = ROW_COUNT;

  RETURN QUERY SELECT v_deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMIT;
